"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pay = exports.updatePaymentRequest = exports.createPaymentRequest = exports.getPaymentRequest = exports.updateOtherAddress = exports.updateDefaultAddress = exports.createId = exports.updateIdConfig = exports.getIdConfig = exports.getId = exports.getSupportedChains = void 0;
const axios_1 = __importDefault(require("axios"));
const config_1 = require("./config");
const types_1 = require("./types");
class Fetcch {
    constructor(apiKey, production = true) {
        this.apiKey = '';
        this.production = true;
        this.getSupportedChains = (params) => {
            return (0, exports.getSupportedChains)(params);
        };
        this.getId = (params) => {
            return (0, exports.getId)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.getIdConfig = (params) => {
            return (0, exports.getIdConfig)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.uupdateIdConfig = (params) => {
            return (0, exports.updateIdConfig)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.createId = (params) => {
            return (0, exports.createId)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.updateDefaultAddress = (params) => {
            return (0, exports.updateDefaultAddress)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.updateOtherAddress = (params) => {
            return (0, exports.updateOtherAddress)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.getPaymentRequest = (params) => {
            return (0, exports.getPaymentRequest)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.createPaymentRequest = (params) => {
            return (0, exports.createPaymentRequest)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.updatePaymentRequest = (params) => {
            return (0, exports.updatePaymentRequest)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.pay = (params) => {
            return (0, exports.pay)({
                apiKey: this.apiKey,
                data: params
            });
        };
        this.apiKey = apiKey;
        this.production = production;
        (0, config_1.setNodeEnv)(this.production);
    }
}
exports.default = Fetcch;
const getSupportedChains = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: "GET",
                url: `${backendURL}/networks/`,
                params: {
                    id: (_a = params === null || params === void 0 ? void 0 : params.data) === null || _a === void 0 ? void 0 : _a.internalId
                },
                headers: {
                    "content-type": "application/json"
                }
            });
            const data = yield res.data;
            if (data.results.length <= 0) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(data.results);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.getSupportedChains = getSupportedChains;
const getId = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data.id && !params.data.signedMsg) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, either send data.id or data.signedMsg`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            let res;
            if (params.data.id) {
                res = yield (0, axios_1.default)({
                    method: 'GET',
                    url: `${backendURL}/id/`,
                    params: params.data,
                    headers: {
                        "x-api-key": params.apiKey
                    }
                });
            }
            else {
                res = yield (0, axios_1.default)({
                    method: 'GET',
                    url: `${backendURL}/id/`,
                    params: {
                        signed_msg: params.data.signedMsg
                    },
                    headers: {
                        "x-api-key": params.apiKey
                    }
                });
            }
            const id = yield res.data.results[0];
            if (!id) {
                reject(new types_1.IdNotFound((params.data.id ? params.data.id : params.data.signedMsg)));
                return;
            }
            resolve(id);
        }
        catch (e) {
            console.log(e);
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.getId = getId;
const getIdConfig = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface ID`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: 'GET',
                url: `${backendURL}/id/config/`,
                params: {
                    id: params.data.id
                },
                headers: {
                    'content-type': "application/json",
                    "x-api-key": params.apiKey
                }
            });
            const idConfig = (yield res.data).results[0];
            if (!idConfig) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(idConfig);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.getIdConfig = getIdConfig;
const updateIdConfig = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface ID`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: 'PUT',
                url: `${backendURL}/id/config/${params.data.configId}/?id=${params.data.wagpayId}`,
                data: params.data,
                headers: {
                    "content-type": "application/json",
                    "x-api-key": params.apiKey
                }
            });
            const idConfig = yield res.data;
            if (!idConfig) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(idConfig);
        }
        catch (e) {
            console.log(e);
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.updateIdConfig = updateIdConfig;
const createId = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface ID`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: 'POST',
                url: `${backendURL}/id/`,
                data: params.data,
                headers: {
                    "content-type": "application/json",
                    "x-api-key": params.apiKey
                }
            });
            const id = yield res.data;
            if (!id) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(id);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.createId = createId;
const updateDefaultAddress = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data.address && !params.data.network) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, either send address or network or both`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: "PUT",
                url: `${backendURL}/id/change_default/`,
                params: {
                    signed_msg: params.data.signedMsg
                },
                data: params.data,
                headers: {
                    "content-type": "application/json",
                    "x-api-key": params.apiKey
                }
            });
            const data = yield res.data;
            if (!data) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(data);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.updateDefaultAddress = updateDefaultAddress;
const updateOtherAddress = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data.delete_address && !params.data.others) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: "PUT",
                url: `${backendURL}/id/change_others/`,
                params: {
                    signed_msg: params.data.signedMsg
                },
                data: params.data,
                headers: {
                    "content-type": "application/json",
                    "x-api-key": params.apiKey
                }
            });
            const data = yield res.data;
            if (!data) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(data);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.updateOtherAddress = updateOtherAddress;
const getPaymentRequest = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if ((params.data.my || !params.data.id) && !params.data.signedMsg) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send valid ECDSA signature`));
            return;
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            let res = undefined;
            if (params.data.id) {
                res = yield (0, axios_1.default)({
                    method: 'GET',
                    url: `${backendURL}/requests/${params.data.id}/`,
                    headers: {
                        "x-api-key": params.apiKey
                    }
                });
                const request = yield res.data;
                resolve([request]);
            }
            if (params.data.my) {
                res = yield (0, axios_1.default)({
                    method: 'GET',
                    url: `${backendURL}/requests/`,
                    params: {
                        my: params.data.my,
                        signed_msg: params.data.signedMsg
                    },
                    headers: {
                        "x-api-key": params.apiKey
                    }
                });
            }
            else {
                res = yield (0, axios_1.default)({
                    method: 'GET',
                    url: `${backendURL}/requests/`,
                    params: {
                        signed_msg: params.data.signedMsg
                    },
                    headers: {
                        "x-api-key": params.apiKey
                    }
                });
            }
            const paymentRequests = yield res.data;
            if (!paymentRequests || paymentRequests.results.length <= 0) {
                reject(new types_1.PaymentRequestNotFound(`Not found payment request for id related to ${params.data.signedMsg}`));
                return;
            }
            resolve(paymentRequests.results);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.getPaymentRequest = getPaymentRequest;
const createPaymentRequest = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface Request`));
            return;
        }
        if (!params.data.message) {
            params.data.message = "Fetcch Payment #7813";
        }
        if (!params.data.label) {
            params.data.label = "FetcchPayment#7813";
        }
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: 'POST',
                url: `${backendURL}/requests/`,
                data: params.data,
                headers: {
                    "x-api-key": params.apiKey
                }
            });
            const id = yield res.data;
            if (!id) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(id);
        }
        catch (e) {
            console.log(e.response.data);
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? (e.response.data.error ? e.response.data.error : e.response.data) : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.createPaymentRequest = createPaymentRequest;
const updatePaymentRequest = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface UpdateRequest`));
            return;
        }
        const _a = params.data, { id: requestId } = _a, data = __rest(_a, ["id"]);
        try {
            const backendURL = (0, config_1.getBackendUrl)().idUrl;
            const res = yield (0, axios_1.default)({
                method: 'PUT',
                url: `${backendURL}/requests/${requestId}/`,
                data: data,
                headers: {
                    "x-api-key": params.apiKey
                }
            });
            const request = yield res.data;
            if (!request) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(request);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? (e.response.data.error ? e.response.data.error : `API responded with status ${statusCode}`) : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.updatePaymentRequest = updatePaymentRequest;
const pay = (params) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        if (!params.apiKey) {
            reject(new types_1.ApiKeyNotValid());
            return;
        }
        if (!params.data) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send data according to interface Request`));
            return;
        }
        if ((!params.data.toConfig.paymentRequest && !params.data.toConfig.toId) || (params.data.toConfig.paymentRequest && params.data.toConfig.toId)) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send either paymentRequest or toId in data.toConfig`));
            return;
        }
        if (params.data.toConfig.toId && !params.data.userConfig.amount) {
            reject(new types_1.ParamsNotCorrect(`params.data is not correct, send userConfig.amount if sending toConfig.toId`));
            return;
        }
        let paymentRequestId = params.data.toConfig.paymentRequest;
        if (params.data.toConfig.toId) {
            const paymentRequest = yield (0, exports.createPaymentRequest)({
                apiKey: params.apiKey,
                data: {
                    fromId: params.data.userConfig.fromId,
                    toId: params.data.toConfig.toId,
                    chain: params.data.userConfig.fromChain,
                    token: params.data.userConfig.fromToken,
                    amount: params.data.userConfig.amount
                }
            });
            paymentRequestId = paymentRequest.id;
        }
        if (!paymentRequestId) {
            reject(new types_1.ApiError(`error in creating a payment request`, 500));
            return;
        }
        console.log(paymentRequestId, params.data);
        try {
            const backendURL = (0, config_1.getBackendUrl)().txUrl;
            const res = yield (0, axios_1.default)({
                method: 'POST',
                url: `${backendURL}/tx/pay/`,
                data: {
                    payment_request_id: paymentRequestId,
                    user_config: {
                        from_id: params.data.userConfig.fromId,
                        from_chain: params.data.userConfig.fromChain,
                        from_token: params.data.userConfig.fromToken,
                        from_address: params.data.userConfig.fromAddress
                    }
                },
                headers: {
                    "x-api-key": params.apiKey
                }
            });
            const transactionData = yield res.data;
            if (!transactionData) {
                reject(new types_1.ApiError("API Responded with status 400", 400));
                return;
            }
            resolve(transactionData);
        }
        catch (e) {
            if (e && e.response && e.response.status) {
                const statusCode = e.response.status;
                const statusText = e.response.data ? e.response.data : `API responded with status ${statusCode}`;
                reject(new types_1.ApiError(JSON.stringify(statusText), statusCode));
            }
            reject(new types_1.ApiError("API Responded with status 400", 400));
        }
    }));
};
exports.pay = pay;
__exportStar(require("./utils"), exports);
__exportStar(require("./config"), exports);
__exportStar(require("./types"), exports);
